<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üëëSkylord Vibrasiüëë Brainwave Player</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: auto;
        }

        #password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #00ff00;
            font-size: 1.2em;
            padding: 20px;
        }

        #password-overlay input[type="password"] {
            padding: 10px;
            margin: 15px 0;
            width: 80%;
            max-width: 300px;
            border: 2px solid #00ff00;
            background-color: #111;
            color: #fff;
            border-radius: 5px;
            font-size: 1em;
        }

        #password-overlay button {
            padding: 10px 20px;
            background-color: #00ff00;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }

        #password-overlay button:hover {
            background-color: #00cc00;
        }

        .player-container {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background-color: #000;
            color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            width: 90%; 
            max-width: 500px;
            margin: 20px auto;
            text-align: center;
        }

        .player-container h1 {
            color: #00ff00;
            margin-bottom: 20px; 
            line-height: 1.2;
        }
        
        #titleSub {
            font-size: 0.7em;
        }

        .player-container input[type="file"], .player-container .file-label {
            display: none;
        }

        .player-container .option-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-container .option-group label {
            margin: 0;
        }

        .player-container .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .player-container button {
            padding: 10px 15px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            white-space: nowrap;
        }
        
        #playBtn, #pauseBtn {
            background-color: #00ff00;
            color: black;
        }
        
        #playBtn:hover, #pauseBtn:hover {
            background-color: #00cc00;
        }

        #stopBtn {
            background-color: #ff0000;
            color: white;
        }

        #stopBtn:hover {
            background-color: #cc0000;
        }
        
        #downloadBtn {
            background-color: #007BFF;
            color: white;
        }
        
        #downloadBtn:hover {
            background-color: #0056b3;
        }
        
        .player-container #status {
            margin-top: 20px;
            font-size: 14px;
            color: #00ff00;
            min-height: 20px;
        }
        
        .player-container #timer {
            font-size: 1.2em;
            font-weight: bold;
            color: #FFFFFF;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div id="password-overlay">
    <h2>Akses Terkunci üîê</h2>
    <p>Masukkan Kata Sandi:</p>
    <input type="password" id="passwordInput" placeholder="Kata Sandi Rahasia" autocomplete="off">
    <button id="submitPasswordBtn">Masuk üîë</button>
    <p id="passwordMessage" style="color: red; margin-top: 10px;"></p>
</div>
<div class="player-container">
    <h1 id="playerTitle">
        <span id="titleMain">üëëSkylord Vibrasiüëë</span><br>
        <span id="titleSub">üéß Brainwave Murni Player üéß</span>
    </h1>
    
    <div class="option-group">
        <input type="checkbox" id="pinkNoiseToggle" checked>
        <label for="pinkNoiseToggle">Aktifkan Noise üîä</label>
    </div>
    
    <div class="option-group">
        <input type="checkbox" id="loopToggle">
        <label for="loopToggle">Ulangi üîÑ (Loop)</label>
    </div>

    <div class="controls">
        <button id="playBtn">Play ‚ñ∂Ô∏è</button>
        <button id="pauseBtn" disabled style="display:none;">Pause ‚è∏Ô∏è</button>
        <button id="stopBtn" disabled>Stop ‚èπÔ∏è</button>
        <button id="downloadBtn">Download üõÖ</button>
    </div>
    <div id="status"></div>
    <div id="timer">00:00</div>
</div>

<script>
    const ENCODED_PASSWORD = "c2t5bG9yZGJs"; 
    const passwordOverlay = document.getElementById('password-overlay');
    const passwordInput = document.getElementById('passwordInput');
    const submitPasswordBtn = document.getElementById('submitPasswordBtn');
    const passwordMessage = document.getElementById('passwordMessage');
    const playerContainer = document.querySelector('.player-container');

    function checkPassword() {
        const DECODED_PASSWORD = atob(ENCODED_PASSWORD); 
        
        if (passwordInput.value === DECODED_PASSWORD) {
            passwordOverlay.style.display = 'none';
            playerContainer.style.display = 'flex'; 
            loadSbgData(); 
        } else {
            passwordMessage.textContent = 'Kata Sandi Salah. Akses Ditolak.';
            passwordInput.value = ''; 
        }
    }
    
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusDiv = document.getElementById('status');
    const timerDiv = document.getElementById('timer');
    const pinkNoiseToggle = document.getElementById('pinkNoiseToggle');
    const loopToggle = document.getElementById('loopToggle');

    let audioContext;
    let oscillatorL, oscillatorR;
    let pinkNoiseSource;
    
    let externalAudioBuffer = null;
    let externalAudioSource = null;
    let externalAudioLoopSources = []; 

    let sbgData = null;
    let isPlaying = false;
    let isPaused = false;
    let timerInterval;
    let playStartTime;
    let totalDuration = 0; 
    let sbgDuration = 0; 
    let pauseOffset = 0;
    
    const EXTERNAL_AUDIO_FILENAME = 'file.wav'; 
    const MASTER_VOLUME = 0.4; 

    const sbgContentToLoad = `
        -SE
alpha10: pink/70 300+10/30
theta4:  pink/20 150+4/80
theta5:  pink/20 150+5/80
theta6:  pink/0 150+6/100
alloff:  -

NOW alpha10
+00:05:00 alpha10 ->
+00:07:00 theta4
+00:12:00 theta4 ->
+00:14:00 theta5
+00:24:00 theta5 ->
+00:25:00 theta6
+00:29:00 theta6 ->
+00:30:00 alloff
    `;

    function parseTime(timeStr) {
        const parts = timeStr.split(':');
        return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
    }

    function createPinkNoiseBuffer(audioContext, duration) {
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = buffer.getChannelData(0);
        
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
        
        for (let i = 0; i < bufferSize; i++) {
            let white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99474 * b1 + white * 0.0750759;
            b2 = 0.97509 * b2 + white * 0.1538520;
            b3 = 0.86200 * b3 + white * 0.3104856;
            b4 = 0.00000 * b4 + white * 0.5329522;
            b5 = -0.18500 * b5 + white * 0.1147000;
            output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.115926;
            b6 = white * 0.115926;
            output[i] *= 0.1;
        }
        return buffer;
    }

    function parseSbg(text) {
        const lines = text.split('\n').filter(line => line.trim() !== '');
        const presets = {};
        const events = [];
        
        presets['alloff'] = {
            noiseType: 'pink',
            noiseVol: 0,
            freqL: 0,
            freqR: 0,
            toneVol: 0
        };

        lines.forEach(line => {
            line = line.trim();
            if (line.startsWith('##') || line.startsWith('-SE')) {
                return;
            }
            const presetMatch = line.match(/^(\w+):\s+([\w\/]+)\s+([\d.]+)\+([\d.]+)\/([\d.]+)/);
            if (presetMatch) {
                const name = presetMatch[1];
                const noiseParts = presetMatch[2].split('/');
                const noiseType = noiseParts[0];
                const noiseVol = parseFloat(noiseParts[1] || 0) / 100;
                const baseFreq = parseFloat(presetMatch[3]);
                const beatFreq = parseFloat(presetMatch[4]);
                const toneVol = parseFloat(presetMatch[5]) / 100;

                presets[name] = {
                    noiseType: noiseType,
                    noiseVol: noiseVol,
                    freqL: baseFreq,
                    freqR: baseFreq + beatFreq,
                    toneVol: toneVol
                };
            }
            const eventMatch = line.match(/^(\+|NOW)\s*([\d:.]*)\s*(\w+)/);
            if (eventMatch) {
                const timeStr = eventMatch[2];
                const presetName = eventMatch[3];
                if (presets[presetName]) {
                    if (eventMatch[1] === 'NOW') {
                        events.push({ time: 0, preset: presetName });
                    } else if (eventMatch[1] === '+') {
                        const timeInSeconds = parseTime(timeStr);
                        events.push({ time: timeInSeconds, preset: presetName });
                    }
                }
            }
        });
        events.sort((a, b) => a.time - b.time);
        return { presets, events };
    }

    function formatDuration(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
    }

    async function loadExternalAudio() {
        if (!window.fetch || !window.AudioContext) {
            return;
        }
        
        statusDiv.textContent = `Memuat (${EXTERNAL_AUDIO_FILENAME}), mohon tunggu...`;
        
        try {
            if (!audioContext || audioContext.state === 'closed') {
                 audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const response = await fetch(EXTERNAL_AUDIO_FILENAME);
            if (!response.ok) {
                 throw new Error(`Gagal memuat file: ${response.statusText}`);
            }
            const arrayBuffer = await response.arrayBuffer();

            externalAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            statusDiv.textContent = `File eksternal berhasil dimuat. Siap dicampur!`;
            
        } catch (error) {
            statusDiv.textContent = `Gagal memuat atau mendekode audio eksternal: ${error.message}. Mode Murni Brainwave Aktif.`;
            externalAudioBuffer = null;
            console.error(error);
        } finally {
            if (sbgData && sbgData.events.length > 0) {
                 playBtn.disabled = false;
                 statusDiv.textContent = `Vibrasi Magnetisme Metafisik Berhasil Ditransfer Skylord ‚úì Play dan Tunggu`;
            }
        }
    }
    
    function updateStatusAndTimer() {
        if (!sbgData || !sbgData.events.length) return; 
        
        const elapsedTime = (Date.now() - playStartTime) / 1000 + pauseOffset;
        
        const isSbgFinished = !loopToggle.checked && elapsedTime >= sbgDuration;

        if (isSbgFinished) {
            if (oscillatorL) {
                oscillatorL.stop(audioContext.currentTime);
                oscillatorL.disconnect();
                oscillatorL = null;
            }
            if (oscillatorR) {
                oscillatorR.stop(audioContext.currentTime);
                oscillatorR.disconnect();
                oscillatorR = null;
            }
            if (pinkNoiseSource) {
                pinkNoiseSource.stop(audioContext.currentTime);
                pinkNoiseSource.disconnect();
                pinkNoiseSource = null;
            }

            if (externalAudioSource) {
                clearInterval(timerInterval);
                isPlaying = false;
                
                statusDiv.textContent = 'Program Sukses !!! Audio Eksternal Berlanjut...';
                
                pauseBtn.disabled = true; 
                playBtn.disabled = true;
            } else {
                stopAudio(); 
                statusDiv.textContent = 'Program Brainwave Selesai. Selamat!';
            }
            
            timerDiv.textContent = `Durasi ${formatDuration(sbgDuration)} / ${formatDuration(sbgDuration)}`;
            
        } else {
            const formattedTime = formatDuration(elapsedTime);
            const formattedDuration = formatDuration(totalDuration);
            timerDiv.textContent = `Mulai ${formattedTime} / ${formattedDuration}`;
            
            let currentEvent = sbgData.events[0];
            for (let i = 0; i < sbgData.events.length; i++) {
                if (sbgData.events[i].time <= elapsedTime) {
                    currentEvent = sbgData.events[i];
                } else {
                    break;
                }
            }
            
            const preset = sbgData.presets[currentEvent.preset];
            if (preset) {
                statusDiv.textContent = `Frekuensi saat ini: ${preset.freqL.toFixed(2)} Hz / ${preset.freqR.toFixed(2)} Hz`;
            }
        }
    }

    function startAudio() {
        if (!sbgData || isPlaying) {
            return;
        }

        isPlaying = true;
        isPaused = false;
        
        if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        audioContext.resume().then(() => {
            const masterGain = audioContext.createGain();
            masterGain.gain.setValueAtTime(MASTER_VOLUME, audioContext.currentTime); 
            masterGain.connect(audioContext.destination);

            const startTime = audioContext.currentTime;
            
            if (externalAudioBuffer) {
                externalAudioLoopSources = [];
                
                externalAudioSource = audioContext.createBufferSource();
                externalAudioSource.buffer = externalAudioBuffer;
                
                externalAudioSource.connect(masterGain); 
                
                const offset = pauseOffset;
                const externalAudioDuration = externalAudioBuffer.duration;
                const stopPoint = startTime + sbgDuration - offset; 
                const totalDurationNeeded = sbgDuration - offset;
                const numLoops = Math.ceil(totalDurationNeeded / externalAudioDuration);
                
                let currentStartTime = 0; 
                let currentOffset = offset;
                
                for (let i = 0; i < numLoops; i++) {
                    const durationToPlay = Math.min(externalAudioDuration - currentOffset, totalDurationNeeded - currentStartTime);
                    
                    if (durationToPlay > 0) {
                        const startPoint = startTime + currentStartTime;
                        
                        let sourceToSchedule;
                        
                        if (i === 0) {
                            sourceToSchedule = externalAudioSource; 
                            sourceToSchedule.start(startPoint, currentOffset); 
                        } else {
                            sourceToSchedule = audioContext.createBufferSource();
                            sourceToSchedule.buffer = externalAudioBuffer;
                            sourceToSchedule.connect(masterGain);
                            
                            sourceToSchedule.start(startPoint, 0); 
                            
                            externalAudioLoopSources.push(sourceToSchedule); 
                        }
                        
                        sourceToSchedule.stop(stopPoint); 
                        
                        currentStartTime += durationToPlay;
                        currentOffset = 0; 
                    }
                }
                
                externalAudioSource.onended = () => {};
            }
            
            
            oscillatorL = audioContext.createOscillator();
            oscillatorR = audioContext.createOscillator();
            
            const gainL = audioContext.createGain();
            const gainR = audioContext.createGain();
            const pannerL = audioContext.createStereoPanner();
            const pannerR = audioContext.createStereoPanner();
            pannerL.pan.setValueAtTime(-1, audioContext.currentTime);
            pannerR.pan.setValueAtTime(1, audioContext.currentTime);
            
            let pinkNoiseGain = null;
            const isPinkNoiseEnabled = pinkNoiseToggle.checked;
            
            if (isPinkNoiseEnabled) {
                const firstPreset = sbgData.presets[sbgData.events[0].preset];
                if (firstPreset && firstPreset.noiseType === 'pink') {
                    pinkNoiseSource = audioContext.createBufferSource();
                    pinkNoiseSource.buffer = createPinkNoiseBuffer(audioContext, sbgDuration); 
                    pinkNoiseSource.loop = loopToggle.checked; 
                    
                    pinkNoiseGain = audioContext.createGain(); 
                    pinkNoiseSource.connect(pinkNoiseGain);
                    pinkNoiseGain.connect(masterGain);
                    pinkNoiseSource.start(0, pauseOffset);
                }
            }
            
            oscillatorL.type = 'sine';
            oscillatorR.type = 'sine';
            
            oscillatorL.connect(gainL);
            gainL.connect(pannerL);
            pannerL.connect(masterGain);
            oscillatorR.connect(gainR);
            gainR.connect(pannerR);
            pannerR.connect(masterGain);

            sbgData.events.forEach(event => {
                const preset = sbgData.presets[event.preset];
                const scheduledTime = startTime + event.time - pauseOffset;

                if (scheduledTime >= startTime) {
                    if (preset) {
                        gainL.gain.linearRampToValueAtTime(preset.toneVol, scheduledTime);
                        gainR.gain.linearRampToValueAtTime(preset.toneVol, scheduledTime);
                        oscillatorL.frequency.linearRampToValueAtTime(preset.freqL, scheduledTime);
                        oscillatorR.frequency.linearRampToValueAtTime(preset.freqR, scheduledTime);
                        
                        if (pinkNoiseGain) {
                            pinkNoiseGain.gain.linearRampToValueAtTime(preset.noiseVol, scheduledTime);
                        }
                    }
                }
            });

            oscillatorL.start(startTime, pauseOffset);
            oscillatorR.start(startTime, pauseOffset);
            
            playStartTime = Date.now();
            timerInterval = setInterval(updateStatusAndTimer, 1000);
            
            playBtn.disabled = true;
            playBtn.style.display = 'none';
            pauseBtn.disabled = false;
            pauseBtn.style.display = 'inline-block';
            stopBtn.disabled = false;
        });
    }

    function stopAudio() {
        if (!isPlaying && !isPaused && !externalAudioSource) {
            return;
        }
        
        if (oscillatorL) {
            oscillatorL.stop();
            oscillatorL.disconnect();
            oscillatorL = null;
        }
        if (oscillatorR) {
            oscillatorR.stop();
            oscillatorR.disconnect();
            oscillatorR = null;
        }
        if (pinkNoiseSource) {
            pinkNoiseSource.stop();
            pinkNoiseSource.disconnect();
            pinkNoiseSource = null;
        }

        if (externalAudioSource) {
            externalAudioSource.stop();
            externalAudioSource.disconnect();
            externalAudioSource = null;
        }
        
        externalAudioLoopSources.forEach(source => {
            if (source) {
                source.stop();
                source.disconnect();
            }
        });
        externalAudioLoopSources = []; 

        if (audioContext && audioContext.state !== 'closed') {
            audioContext.close();
        }

        isPlaying = false;
        isPaused = false;
        clearInterval(timerInterval);
        timerDiv.textContent = `Selesai 00:00 / ${formatDuration(totalDuration)}`;
        statusDiv.textContent = 'Selamat Program Anda Berjalan Sukses !!!';
        playBtn.disabled = false;
        playBtn.style.display = 'inline-block';
        pauseBtn.disabled = true;
        pauseBtn.style.display = 'none';
        stopBtn.disabled = true;
        pauseBtn.textContent = 'Pause ‚è∏Ô∏è';
        pauseOffset = 0;
    }

    function pauseAudio() {
        if (isPlaying) {
            isPlaying = false;
            isPaused = true;
            audioContext.suspend().then(() => {
                pauseBtn.textContent = 'Resume ‚èØÔ∏è';
                statusDiv.textContent = 'Pemutaran dijeda';
                clearInterval(timerInterval);
                pauseOffset = (Date.now() - playStartTime) / 1000 + pauseOffset;
            });
        }
    }

    function resumeAudio() {
        if (isPaused) {
            isPlaying = true;
            isPaused = false;
            audioContext.resume().then(() => {
                pauseBtn.textContent = 'Pause ‚è∏Ô∏è';
                statusDiv.textContent = 'Melanjutkan pemutaran...';
                playStartTime = Date.now();
                timerInterval = setInterval(updateStatusAndTimer, 1000);
            });
        }
    }

    function renderAudioForDownload(duration) {
        const sampleRate = 44100;
        const offlineCtx = new OfflineAudioContext(2, duration * sampleRate, sampleRate);

        const masterGain = offlineCtx.createGain();
        masterGain.gain.setValueAtTime(MASTER_VOLUME, offlineCtx.currentTime); 
        masterGain.connect(offlineCtx.destination);

        const startTime = offlineCtx.currentTime;

        if (externalAudioBuffer) {
            const externalAudioDuration = externalAudioBuffer.duration;
            const totalDurationNeeded = duration; 
            const numLoops = Math.ceil(totalDurationNeeded / externalAudioDuration);
            
            let currentStartTime = 0; 
            
            for (let i = 0; i < numLoops; i++) {
                const durationToPlay = Math.min(externalAudioDuration, totalDurationNeeded - currentStartTime);
                
                if (durationToPlay > 0) {
                    const startPoint = startTime + currentStartTime;
                    const stopPoint = startTime + duration;
                    
                    const externalDownloadSource = offlineCtx.createBufferSource();
                    externalDownloadSource.buffer = externalAudioBuffer;
                    externalDownloadSource.loop = false;
                    externalDownloadSource.connect(masterGain); 
                    
                    externalDownloadSource.start(startPoint, 0, durationToPlay);
                    externalDownloadSource.stop(stopPoint);
                    
                    currentStartTime += durationToPlay;
                }
            }
        }

        
        const oscillatorL = offlineCtx.createOscillator();
        const oscillatorR = offlineCtx.createOscillator();

        const gainL = offlineCtx.createGain();
        const gainR = offlineCtx.createGain();
        const pannerL = offlineCtx.createStereoPanner();
        const pannerR = offlineCtx.createStereoPanner();
        pannerL.pan.setValueAtTime(-1, offlineCtx.currentTime);
        pannerR.pan.setValueAtTime(1, offlineCtx.currentTime);

        let pinkNoiseSource = null;
        let pinkNoiseGain = null;
        if (pinkNoiseToggle.checked) {
            pinkNoiseSource = offlineCtx.createBufferSource();
            pinkNoiseSource.buffer = createPinkNoiseBuffer(offlineCtx, duration); 
            pinkNoiseSource.loop = false; 
            pinkNoiseGain = offlineCtx.createGain();
            pinkNoiseSource.connect(pinkNoiseGain);
            pinkNoiseGain.connect(masterGain);
            pinkNoiseSource.start(0);
        }

        oscillatorL.type = 'sine';
        oscillatorR.type = 'sine';
        oscillatorL.connect(gainL);
        gainL.connect(pannerL);
        pannerL.connect(masterGain);
        oscillatorR.connect(gainR);
        gainR.connect(pannerR);
        pannerR.connect(masterGain);

        
        sbgData.events.forEach(event => {
            const preset = sbgData.presets[event.preset];
            const scheduledTime = startTime + event.time;

            if (preset) {
                gainL.gain.linearRampToValueAtTime(preset.toneVol, scheduledTime);
                gainR.gain.linearRampToValueAtTime(preset.toneVol, scheduledTime);
                oscillatorL.frequency.linearRampToValueAtTime(preset.freqL, scheduledTime);
                oscillatorR.frequency.linearRampToValueAtTime(preset.freqR, scheduledTime);
                if (pinkNoiseSource) {
                    pinkNoiseGain.gain.linearRampToValueAtTime(preset.noiseVol, scheduledTime);
                }
            }
        });

        
        oscillatorL.start(startTime);
        oscillatorR.start(startTime);
        oscillatorL.stop(duration);
        oscillatorR.stop(duration);
        if (pinkNoiseSource) {
            pinkNoiseSource.stop(duration);
        }
        
        return offlineCtx.startRendering();
    }


    function audioBufferToWavBlob(audioBuffer) {
        const numOfChan = audioBuffer.numberOfChannels;
        const totalLength = audioBuffer.length * numOfChan * 2 + 44;
        const samples = new Int16Array(audioBuffer.length * numOfChan);
        
        for (let i = 0; i < audioBuffer.length; i++) {
            for (let channel = 0; channel < numOfChan; channel++) {
                const sample = audioBuffer.getChannelData(channel)[i];
                const intSample = Math.max(-1, Math.min(1, sample)) * 32767;
                samples[i * numOfChan + channel] = intSample;
            }
        }

        const buffer = new ArrayBuffer(totalLength);
        const view = new DataView(buffer);

        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numOfChan, true);
        view.setUint32(24, audioBuffer.sampleRate, true);
        view.setUint32(28, audioBuffer.sampleRate * 2 * numOfChan, true);
        view.setUint16(32, numOfChan * 2, true);
        view.setUint16(34, 16, true);
        writeString(view, 36, 'data');
        view.setUint32(40, samples.length * 2, true);

        let offset = 44;
        for (let i = 0; i < samples.length; i++, offset += 2) {
            view.setInt16(offset, samples[i], true);
        }

        return new Blob([view], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    function loadSbgData() {
        try {
            sbgData = parseSbg(sbgContentToLoad);
            if (sbgData && sbgData.events.length > 0) {
                sbgDuration = sbgData.events[sbgData.events.length - 1].time;
                totalDuration = sbgDuration;
                timerDiv.textContent = `Durasi 00:00 / ${formatDuration(totalDuration)}`;
                statusDiv.textContent = `Memuat Audio Eksternal...`; 
                playBtn.disabled = true; 
                downloadBtn.disabled = false;
            } else {
                statusDiv.textContent = 'Gagal memproses file .sbg. Skylord Menolak Akses Anda';
                playBtn.disabled = true;
                downloadBtn.disabled = true;
            }
        } catch (error) {
            statusDiv.textContent = `Terjadi kesalahan saat memproses data: ${error.message}`;
            playBtn.disabled = true;
            downloadBtn.disabled = true;
        }
        
        loadExternalAudio();
    }
    
    submitPasswordBtn.addEventListener('click', checkPassword);
    passwordInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            checkPassword();
        }
    });

    playBtn.addEventListener('click', startAudio);
    stopBtn.addEventListener('click', stopAudio);
    
    pauseBtn.addEventListener('click', () => {
        if (isPaused) {
            resumeAudio();
        } else {
            pauseAudio();
        }
    });
    
    downloadBtn.addEventListener('click', () => {
        if (!sbgData || sbgData.events.length === 0) {
            statusDiv.textContent = 'Tidak ada file untuk diunduh.';
            return;
        }

        statusDiv.textContent = 'Skylord Membuat File Audio Mix, Mohon Tunggu...';
        playBtn.disabled = true;
        pauseBtn.disabled = true;
        stopBtn.disabled = true;
        downloadBtn.disabled = true;
        
        if (isPlaying || isPaused) {
            stopAudio();
        }

        renderAudioForDownload(totalDuration) 
            .then(audioBuffer => {
                const wavBlob = audioBufferToWavBlob(audioBuffer);
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'vibrasi-mix-alpha.wav'; 
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusDiv.textContent = 'File .wav Mix Berhasil Dibuat Oleh Skylord dan Siap Diunduh!';
                playBtn.disabled = false;
                downloadBtn.disabled = false;
            })
            .catch(error => {
                statusDiv.textContent = `Terjadi kesalahan saat membuat file audio: ${error.message}`;
                playBtn.disabled = false;
                downloadBtn.disabled = false;
            });
    });
</script>

</body>
</html>

